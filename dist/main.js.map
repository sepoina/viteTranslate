{"mappings":"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","sources":["progetti/viteTranslate/src/index.js","progetti/viteTranslate/src/dev/babel/babelTranslate.js","progetti/viteTranslate/src/dev/babel/getChildrenText.js","progetti/viteTranslate/src/dev/babel/getVariableProps.js","progetti/viteTranslate/src/dev/rollup/rollupTranslate.js","progetti/viteTranslate/src/components/TranslateContainer.jsx","progetti/viteTranslate/src/components/Translate.jsx"],"sourcesContent":["import babelTranslate from \"./dev/babel/babelTranslate\";\nimport rollupTranslate from \"./dev/rollup/rollupTranslate\";\nimport TranslateContainer from \"./components/TranslateContainer\";\nimport { TranslateContext } from \"./components/TranslateContainer\";\nimport Translate from \"./components/Translate\";\n\nexport {\n  babelTranslate,\n  rollupTranslate,\n  TranslateContainer,\n  TranslateContext,\n  Translate,\n};\n","import getChildrenText from \"./getChildrenText\";\nimport getVariableProps from \"./getVariableProps\";\nimport pathCmd from \"path\";\nimport hash from \"fnv1a\";\n\n//\n// se in input trova un _%_testo_%_\n// aggiunge \"testo\" alla tabella di traduzioni\n// e trasforma \"_%_testo_%_\" in \"_<_id_#_testo_>_\"\n//\nfunction ifStaticAddTable(p, state) {\n  if (!p?.node?.value) return; // non trova l'oggetto\n  if (!/_%_(.*?)_%_/.test(p.node.value)) return; // non trova il riconoscitore\n  const strToAdd = /_%_(.*?)_%_/.exec(p.node.value)?.[1];\n  if (!strToAdd) return; // è vuota o nulla\n  //  console.log(\"trovato da rimpiazzare:\", p.node.value);\n  const data_translate = addToTable(strToAdd, state);\n  p.node.value = getReplacedForTranslate(\n    p.node.value,\n    data_translate,\n    strToAdd\n  );\n  if (p.node.extra.rawValue)\n    p.node.extra.rawValue = getReplacedForTranslate(\n      p.node.extra.rawValue,\n      data_translate,\n      strToAdd\n    );\n  if (p.node.extra.raw)\n    p.node.extra.raw = getReplacedForTranslate(\n      p.node.extra.raw,\n      data_translate,\n      strToAdd\n    );\n  // console.log(\"rimpiazzo:\", p.node.value);\n}\n\n// getta il testo da value e trasforma \"_%_testo_%_\" in \"_<_id_/_testo_>_\"\nfunction getReplacedForTranslate(value, data_translate, text) {\n  const newString = `_<_${data_translate}_/_${text}_>_`;\n  return value.replace(/_%_(.*?)_%_/, newString);\n}\n\nfunction addToTable(strToAdd, state) {\n  //\n  //\n  // recupera il nome del file su cui si trova il translate\n  const nameFile = pathCmd.parse(state.filename).name;\n  //\n  //\n  // calcola l'hash\n  const hex = hash(strToAdd).toString(36);\n  //\n  // va iniettato\n  // console.log(path);\n  const data_translate = `${nameFile}_${hex}`;\n  // console.log(`add to table:${data_translate} value:${strToAdd}`);\n  // assegna\n  globalThis[\"TranslateService\"][\"baseLng\"][data_translate] = strToAdd;\n  return data_translate; // id\n}\n\nexport default api => {\n  const { types: t } = api;\n\n  return {\n    visitor: {\n      // Aggiungi il tuo visitor per le stringhe costanti\n      StringLiteral: ifStaticAddTable,\n      JSXText: ifStaticAddTable,\n      TemplateElement: ifStaticAddTable,\n      JSXOpeningElement(path, state) {\n        //\n        // prova ad aprirlo... è translate? se no torna\n        if (path.node.name.name !== \"Translate\") return;\n        //\n        // ha giù la props data-translate? torna\n        const existingProp = path.node.attributes.find(\n          node => node?.name?.name === \"data-translate\"\n        );\n        if (existingProp) return;\n        //\n        // se contiene c come props la traduzione è differita, ritorna\n        //\n        if (path.node.attributes.find(n => n?.name.name === \"c\")) return;\n        //\n        // se ha un props chiamato 't' lo carica altrimenti carica il contenuto\n        // dei children, se nessuno dei due ha un text mostra un errore\n        const textInternal = path.node.attributes.find(\n          node => node?.name?.name === \"t\"\n        );\n        const text = textInternal\n          ? getVariableProps(\"t\", path)\n          : getChildrenText(path);\n        if (text === false)\n          throw \"Errore, Translate deve contenere solo stringhe\";\n        //\n        // aggiunge alla tabella\n        const data_translate = addToTable(text, state);\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"data-translate\"),\n          t.stringLiteral(data_translate)\n        );\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n","//\n// restituisce il testo di un children\n// o false se non è un testo recuperabile\n//\nexport default function getChildrenText(p) {\n  // console.log('Carico dai children:', p);\n  if (p?.container?.children?.length === 1) {\n    const child = p.container.children[0];\n    // se è un testo ok\n    if (child.type === \"JSXText\") return child.value;\n    // se è un calcolo ok se calcolabile subito\n    else if (\n      child.type === \"JSXExpressionContainer\" &&\n      child?.expression?.value\n    )\n      return child.expression.value;\n    else return false;\n  }\n  // altrimenti è un errore\n  return false;\n}\n","//\n// prende la variabile 'variableName' se esiste tra i props o torna false\nexport default function getVariableProps(variableName, p) {\n  // console.log('Carico dalle variabili in linea:', p);\n  const node = p.node.attributes.find(\n    node => node?.name?.name === variableName\n  );\n  if (!node) return false;\n  // ok è una stringa\n  if (node?.value?.type === \"StringLiteral\") return node.value.value;\n  // o è calcolabile come stringa\n  if (\n    node?.value?.type === \"JSXExpressionContainer\" &&\n    node?.value?.expression?.type === \"StringLiteral\"\n  )\n    return node.value.expression.value;\n  return false;\n}\n","import fs from \"fs\";\n\nexport default function rollupTranslate(defs) {\n  return {\n    name: \"onRollupTranslate\",\n    buildStart: {\n      sequential: true,\n      order: \"pre\",\n      handler: () => {\n        //\n        // la public dir è di solito {workspace}/public\n        //\n        globalThis[\"TranslateService\"] = defs;\n        globalThis[\"TranslateService\"].baseLng = {\n          __lngVersion__: CalcolaVersion(),\n        }; // spazio vuoto per gli elementi\n        console.log(\"Preparo il servizio traduzioni.\");\n      },\n    },\n    buildEnd: {\n      sequential: true,\n      order: \"post\",\n      handler: () => {\n        updateFileLanguage();\n      },\n    },\n  };\n}\n\n/**\n * Aggiorna un file di lingua JSON con dati di traduzione. Se il file non esiste, crea un nuovo file\n * utilizzando i dati di traduzione di base forniti. La funzione confronta e aggiorna i dati presenti\n * nel file con i nuovi dati di traduzione, salvando le modifiche solo se sono state apportate variazioni.\n *\n * @function\n * @returns {void}\n *\n * @description\n * Questa funzione legge il contenuto di un file JSON di lingua e lo confronta con i dati di traduzione\n * di base forniti. Se il file non esiste, viene creato utilizzando i dati di traduzione di base. Se ci\n * sono variazioni nei dati di traduzione, le modifiche vengono salvate nel file. La funzione fornisce\n * messaggi di log dettagliati durante il processo.\n *\n */\nfunction updateFileLanguage() {\n  // Specifica il percorso del tuo file JSON\n  const filePath = globalThis[\"TranslateService\"].file;\n  const distPath = globalThis[\"TranslateService\"].dist;\n  console.log(\"TRANSLATE ---------------------------------------------\");\n  console.log(\"Carico traduzione base.\");\n  try {\n    fs.readFile(filePath, \"utf8\", (err, data) => {\n      let state = { newest: true, changed: true },\n        baseData = null;\n      if (err) {\n        console.log(`Non esiste ancora il file ${filePath}, tento di crearlo`);\n        baseData = globalThis[\"TranslateService\"].baseLng; // questi i dati\n      } else {\n        baseData = JSON.parse(data);\n        const newData = globalThis[\"TranslateService\"].baseLng;\n        state = decade(baseData, newData); // se ci sono variazioni\n      }\n      if (state.changed) {\n        // sono avvenute variazioni, salva\n        const stats = state.newest\n          ? \"Nuovo file,\"\n          : `(${state.added} agginte, ${state.deleted} rimosse)`;\n        console.log(`Update avvenuto: ${stats} salvo.`);\n        fs.writeFile(\n          filePath,\n          JSON.stringify(baseData, null, 2),\n          \"utf8\",\n          err => {\n            if (err) {\n              console.error(`Errore durante la scrittura su ${filePath}`, err);\n            } else {\n              console.log(`Dati scritti con successo su ${filePath}`);\n              fs.copyFile(filePath, distPath, err => {\n                if (!err) console.log(`Copiato con successo su ${distPath}`);\n                console.log(\n                  \"END TRANSLATE ---------------------------------------------\"\n                );\n              });\n            }\n          }\n        );\n      } else {\n        console.log(\"Nessun cambiamento.\");\n        console.log(\n          \"END TRANSLATE ---------------------------------------------\"\n        );\n      }\n    });\n  } catch (error) {\n    console.error(`Errore l'elaborazione di ${filePath}, cancellalo`, error);\n    return;\n  }\n}\n\n/**\n * Funzione per confrontare due oggetti e apportare modifiche.\n *\n * @param {Object} a - Primo oggetto da confrontare e modificare.\n * @param {Object} b - Secondo oggetto per il confronto.\n * @returns {boolean} Restituisce true se ci sono state modifiche, altrimenti false.\n *\n * @example\n * const oggettoA = { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\" };\n * const oggettoB = { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\", \"NuovaChiave\": \"NuovoValore\" };\n * const ciSonoVariazioni = decade(oggettoA, oggettoB);\n * console.log(oggettoA); // { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\", \"NuovaChiave\": \"NuovoValore\" }\n * console.log('Ci sono variazioni:', ciSonoVariazioni); // Ci sono variazioni: true\n */\nfunction decade(a, b) {\n  const stats = { changed: false, deleted: 0, added: 0 };\n  // Rimuovi le chiavi da 'a' che non sono presenti in 'b'\n  for (const keyA in a) {\n    if (!(keyA in b)) {\n      delete a[keyA];\n      stats.changed = true;\n      stats.deleted += 1;\n    }\n  }\n  // Aggiungi le chiavi da 'b' che non sono presenti in 'a'\n  for (const keyB in b) {\n    if (!(keyB in a)) {\n      a[keyB] = b[keyB];\n      stats.changed = true;\n      stats.added += 1;\n    }\n  }\n  if (stats.changed) a[\"__lngVersion__\"] = b[\"__lngVersion__\"]; // riporta in a la versione corrente\n  return stats;\n}\n\nfunction CalcolaVersion() {\n  return Date.now();\n}\n","import * as React from \"react\";\r\nimport { createContext } from \"react\";\r\n\r\nexport const TranslateContext = createContext(null);\r\n\r\nconst last = { langID: null };\r\n\r\nexport default function TranslateContainer({ children }) {\r\n  const [langID, setLangID] = React.useState(\"it\");\r\n  const [langOBJ, setLangOBJ] = React.useState(null);\r\n\r\n  const handleChangeLanguage = newLanguage => {\r\n    setLangID(newLanguage);\r\n  };\r\n\r\n  React.useEffect(() => {\r\n    if (!langID) return;\r\n    if (last.langID === langID) return; // già in caricamento\r\n    last.langID = langID;\r\n\r\n    // declare the async data fetching function\r\n    const fetchData = async () => {\r\n      try {\r\n        // get the data from the api\r\n        // console.log(\"Carico:\", langID);\r\n        const response = await fetch(`./locale/${langID}.json`);\r\n        // convert the data to json\r\n        const json = await response.json();\r\n        // set state with the result\r\n        // console.log(\"Fatto.\");\r\n        setLangOBJ({\r\n          id: langID,\r\n          table: json,\r\n          setNewLanguage: handleChangeLanguage,\r\n        });\r\n      } catch (error) {\r\n        console.log(`Errore nel file locale/${langID}.json `);\r\n        return;\r\n      }\r\n    };\r\n\r\n    // call the function\r\n    fetchData()\r\n      // make sure to catch any error\r\n      .catch(console.error);\r\n  }, [langID]);\r\n\r\n  return (\r\n    <TranslateContext.Provider value={langOBJ}>\r\n      {children}\r\n    </TranslateContext.Provider>\r\n  );\r\n}\r\n","import { useContext, useMemo } from \"react\";\r\nimport { TranslateContext } from \"./TranslateContainer\";\r\n/**\r\n * t -> testo da mostrare\r\n * a -> array di campi che iniettano il testo da mostrare\r\n * c -> testo da costante javascript iniettata\r\n * children -> eventuali figli\r\n */\r\nexport default function Translate({\r\n  \"data-translate\": dataTranslate,\r\n  t,\r\n  c,\r\n  a,\r\n  children,\r\n}) {\r\n  const lang = useContext(TranslateContext);\r\n  //\r\n  // evita il rendering se non cambia lingua o array di dati\r\n  return useMemo(() => {\r\n    let inputString = c || t || children;\r\n    // console.log(\"rerender:\", inputString);\r\n    //\r\n    // non c'è dataTranslate, può essere che sia inlinea, se lo è è nel parametro c\r\n    if (!dataTranslate) {\r\n      const matches = inputString.match(/_<_(.*?)_\\/_(.*?)_>_/);\r\n      if (matches) {\r\n        dataTranslate = matches[1]; // Contenuto tra \"_<_\" e \"_/_\"\r\n        inputString = matches[2]; // Contenuto tra \"_/_\" e \"_>_\"\r\n      } else {\r\n        throw \"errore nel servizio di traduzione, manca translate\";\r\n      }\r\n    }\r\n    //\r\n    // c'è traduzione\r\n    if (lang?.table?.[dataTranslate])\r\n      return (\r\n        <span data-from-translate={dataTranslate}>\r\n          {a\r\n            ? sostitui(lang.table[dataTranslate], a)\r\n            : lang.table[dataTranslate]}\r\n        </span>\r\n      );\r\n    //\r\n    // non c'è traduzione\r\n    return (\r\n      <span data-not-translate={dataTranslate}>\r\n        {a ? sostitui(inputString, a) : inputString}\r\n      </span>\r\n    );\r\n  }, [lang, a]); // solo il cambio di lingua e di array obbliga il re-rendering\r\n}\r\n\r\n//\r\n// filla le variabili nel template\r\n//     es: text='Siamo al:%0/%1' e ['20%','100%']\r\n//              'Siamo al:%0' e '20%'\r\n//\r\nfunction sostitui(text, args) {\r\n  // se non ci sono argomenti torna sè stesso\r\n  if (args === undefined) return text;\r\n  // definisce il contenitore\r\n  const list = Array.isArray(args) ? args : [args]; // se args[0] è un array è lui la lista sennò lo mette in un array monoelemento\r\n\r\n  let counter = 0;\r\n  const replacedString = text.replace(/%s/g, () => list[counter++]);\r\n  return replacedString;\r\n  /*\r\n    // log(text, args);\r\n    // https://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format#\r\n    // var args = Array.prototype.slice.call(arguments, 1);\r\n    return text.replace(/%(\\d+)/g, function (match, number) {\r\n        return typeof list[number] != 'undefined'\r\n            ? list[number]\r\n            : match\r\n            ;\r\n    });*/\r\n}\r\n"],"names":[],"version":3,"file":"main.js.map"}