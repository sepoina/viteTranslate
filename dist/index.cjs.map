{"version":3,"file":"index.cjs","sources":["../src/dev/babel/babelTranslate.js","../src/dev/babel/getVariableProps.js","../src/dev/babel/getChildrenText.js","../src/dev/rollup/rollupTranslate.js"],"sourcesContent":["import getChildrenText from \"./getChildrenText\";\nimport getVariableProps from \"./getVariableProps\";\nimport pathCmd from \"path\";\nimport hash from \"fnv1a\";\n\n//\n// se in input trova un _%_testo_%_\n// aggiunge \"testo\" alla tabella di traduzioni\n// e trasforma \"_%_testo_%_\" in \"_<_id_#_testo_>_\"\n//\nfunction ifStaticAddTable(p, state) {\n  if (!p?.node?.value) return; // non trova l'oggetto\n  if (!/_%_(.*?)_%_/.test(p.node.value)) return; // non trova il riconoscitore\n  const strToAdd = /_%_(.*?)_%_/.exec(p.node.value)?.[1];\n  if (!strToAdd) return; // è vuota o nulla\n  //  console.log(\"trovato da rimpiazzare:\", p.node.value);\n  const data_translate = addToTable(strToAdd, state);\n  p.node.value = getReplacedForTranslate(\n    p.node.value,\n    data_translate,\n    strToAdd\n  );\n  if (p.node.extra.rawValue)\n    p.node.extra.rawValue = getReplacedForTranslate(\n      p.node.extra.rawValue,\n      data_translate,\n      strToAdd\n    );\n  if (p.node.extra.raw)\n    p.node.extra.raw = getReplacedForTranslate(\n      p.node.extra.raw,\n      data_translate,\n      strToAdd\n    );\n  // console.log(\"rimpiazzo:\", p.node.value);\n}\n\n// getta il testo da value e trasforma \"_%_testo_%_\" in \"_<_id_/_testo_>_\"\nfunction getReplacedForTranslate(value, data_translate, text) {\n  const newString = `_<_${data_translate}_/_${text}_>_`;\n  return value.replace(/_%_(.*?)_%_/, newString);\n}\n\nfunction addToTable(strToAdd, state) {\n  //\n  //\n  // recupera il nome del file su cui si trova il translate\n  const nameFile = pathCmd.parse(state.filename).name;\n  //\n  //\n  // calcola l'hash\n  const hex = hash(strToAdd).toString(36);\n  //\n  // va iniettato\n  // console.log(path);\n  const data_translate = `${nameFile}_${hex}`;\n  // console.log(`add to table:${data_translate} value:${strToAdd}`);\n  // assegna\n  globalThis[\"TranslateService\"][\"baseLng\"][data_translate] = strToAdd;\n  return data_translate; // id\n}\n\nexport default api => {\n  const { types: t } = api;\n\n  return {\n    visitor: {\n      // Aggiungi il tuo visitor per le stringhe costanti\n      StringLiteral: ifStaticAddTable,\n      JSXText: ifStaticAddTable,\n      TemplateElement: ifStaticAddTable,\n      JSXOpeningElement(path, state) {\n        //\n        // prova ad aprirlo... è translate? se no torna\n        if (path.node.name.name !== \"Translate\") return;\n        //\n        // ha giù la props data-translate? torna\n        const existingProp = path.node.attributes.find(\n          node => node?.name?.name === \"data-translate\"\n        );\n        if (existingProp) return;\n        //\n        // se contiene c come props la traduzione è differita, ritorna\n        //\n        if (path.node.attributes.find(n => n?.name.name === \"c\")) return;\n        //\n        // se ha un props chiamato 't' lo carica altrimenti carica il contenuto\n        // dei children, se nessuno dei due ha un text mostra un errore\n        const textInternal = path.node.attributes.find(\n          node => node?.name?.name === \"t\"\n        );\n        const text = textInternal\n          ? getVariableProps(\"t\", path)\n          : getChildrenText(path);\n        if (text === false)\n          throw \"Errore, Translate deve contenere solo stringhe\";\n        //\n        // aggiunge alla tabella\n        const data_translate = addToTable(text, state);\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"data-translate\"),\n          t.stringLiteral(data_translate)\n        );\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n","//\n// prende la variabile 'variableName' se esiste tra i props o torna false\nexport default function getVariableProps(variableName, p) {\n  // console.log('Carico dalle variabili in linea:', p);\n  const node = p.node.attributes.find(\n    node => node?.name?.name === variableName\n  );\n  if (!node) return false;\n  // ok è una stringa\n  if (node?.value?.type === \"StringLiteral\") return node.value.value;\n  // o è calcolabile come stringa\n  if (\n    node?.value?.type === \"JSXExpressionContainer\" &&\n    node?.value?.expression?.type === \"StringLiteral\"\n  )\n    return node.value.expression.value;\n  return false;\n}\n","//\n// restituisce il testo di un children\n// o false se non è un testo recuperabile\n//\nexport default function getChildrenText(p) {\n  // console.log('Carico dai children:', p);\n  if (p?.container?.children?.length === 1) {\n    const child = p.container.children[0];\n    // se è un testo ok\n    if (child.type === \"JSXText\") return child.value;\n    // se è un calcolo ok se calcolabile subito\n    else if (\n      child.type === \"JSXExpressionContainer\" &&\n      child?.expression?.value\n    )\n      return child.expression.value;\n    else return false;\n  }\n  // altrimenti è un errore\n  return false;\n}\n","import fs from \"fs\";\n\nexport default function rollupTranslate(defs) {\n  return {\n    name: \"onRollupTranslate\",\n    buildStart: {\n      sequential: true,\n      order: \"pre\",\n      handler: () => {\n        //\n        // la public dir è di solito {workspace}/public\n        //\n        globalThis[\"TranslateService\"] = defs;\n        globalThis[\"TranslateService\"].baseLng = {\n          __lngVersion__: CalcolaVersion(),\n        }; // spazio vuoto per gli elementi\n        console.log(\"Preparo il servizio traduzioni.\");\n      },\n    },\n    buildEnd: {\n      sequential: true,\n      order: \"post\",\n      handler: () => {\n        updateFileLanguage();\n      },\n    },\n  };\n}\n\n/**\n * Aggiorna un file di lingua JSON con dati di traduzione. Se il file non esiste, crea un nuovo file\n * utilizzando i dati di traduzione di base forniti. La funzione confronta e aggiorna i dati presenti\n * nel file con i nuovi dati di traduzione, salvando le modifiche solo se sono state apportate variazioni.\n *\n * @function\n * @returns {void}\n *\n * @description\n * Questa funzione legge il contenuto di un file JSON di lingua e lo confronta con i dati di traduzione\n * di base forniti. Se il file non esiste, viene creato utilizzando i dati di traduzione di base. Se ci\n * sono variazioni nei dati di traduzione, le modifiche vengono salvate nel file. La funzione fornisce\n * messaggi di log dettagliati durante il processo.\n *\n */\nfunction updateFileLanguage() {\n  // Specifica il percorso del tuo file JSON\n  const filePath = globalThis[\"TranslateService\"].file;\n  const distPath = globalThis[\"TranslateService\"].dist;\n  console.log(\"TRANSLATE ---------------------------------------------\");\n  console.log(\"Carico traduzione base.\");\n  try {\n    fs.readFile(filePath, \"utf8\", (err, data) => {\n      let state = { newest: true, changed: true },\n        baseData = null;\n      if (err) {\n        console.log(`Non esiste ancora il file ${filePath}, tento di crearlo`);\n        baseData = globalThis[\"TranslateService\"].baseLng; // questi i dati\n      } else {\n        baseData = JSON.parse(data);\n        const newData = globalThis[\"TranslateService\"].baseLng;\n        state = decade(baseData, newData); // se ci sono variazioni\n      }\n      if (state.changed) {\n        // sono avvenute variazioni, salva\n        const stats = state.newest\n          ? \"Nuovo file,\"\n          : `(${state.added} agginte, ${state.deleted} rimosse)`;\n        console.log(`Update avvenuto: ${stats} salvo.`);\n        fs.writeFile(\n          filePath,\n          JSON.stringify(baseData, null, 2),\n          \"utf8\",\n          err => {\n            if (err) {\n              console.error(`Errore durante la scrittura su ${filePath}`, err);\n            } else {\n              console.log(`Dati scritti con successo su ${filePath}`);\n              fs.copyFile(filePath, distPath, err => {\n                if (!err) console.log(`Copiato con successo su ${distPath}`);\n                console.log(\n                  \"END TRANSLATE ---------------------------------------------\"\n                );\n              });\n            }\n          }\n        );\n      } else {\n        console.log(\"Nessun cambiamento.\");\n        console.log(\n          \"END TRANSLATE ---------------------------------------------\"\n        );\n      }\n    });\n  } catch (error) {\n    console.error(`Errore l'elaborazione di ${filePath}, cancellalo`, error);\n    return;\n  }\n}\n\n/**\n * Funzione per confrontare due oggetti e apportare modifiche.\n *\n * @param {Object} a - Primo oggetto da confrontare e modificare.\n * @param {Object} b - Secondo oggetto per il confronto.\n * @returns {boolean} Restituisce true se ci sono state modifiche, altrimenti false.\n *\n * @example\n * const oggettoA = { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\" };\n * const oggettoB = { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\", \"NuovaChiave\": \"NuovoValore\" };\n * const ciSonoVariazioni = decade(oggettoA, oggettoB);\n * console.log(oggettoA); // { \"App_f9xds4\": \"rob\", \"App_y3mo81\": \"Santanastaso\", \"NuovaChiave\": \"NuovoValore\" }\n * console.log('Ci sono variazioni:', ciSonoVariazioni); // Ci sono variazioni: true\n */\nfunction decade(a, b) {\n  const stats = { changed: false, deleted: 0, added: 0 };\n  // Rimuovi le chiavi da 'a' che non sono presenti in 'b'\n  for (const keyA in a) {\n    if (!(keyA in b)) {\n      delete a[keyA];\n      stats.changed = true;\n      stats.deleted += 1;\n    }\n  }\n  // Aggiungi le chiavi da 'b' che non sono presenti in 'a'\n  for (const keyB in b) {\n    if (!(keyB in a)) {\n      a[keyB] = b[keyB];\n      stats.changed = true;\n      stats.added += 1;\n    }\n  }\n  if (stats.changed) a[\"__lngVersion__\"] = b[\"__lngVersion__\"]; // riporta in a la versione corrente\n  return stats;\n}\n\nfunction CalcolaVersion() {\n  return Date.now();\n}\n"],"names":["ifStaticAddTable","p","state","_p$node","_exec","node","value","test","strToAdd","exec","data_translate","addToTable","getReplacedForTranslate","extra","rawValue","raw","text","replace","pathCmd","parse","filename","name","hash","toString","globalThis","api","t","types","visitor","StringLiteral","JSXText","TemplateElement","JSXOpeningElement","path","existingProp","attributes","find","_node$name","n","_node$value","_node$value2","_node$value3","textInternal","_node$name2","type","expression","_p$container","container","children","length","_child$expression","child","getChildrenText","newProp","jSXAttribute","jSXIdentifier","stringLiteral","push","defs","buildStart","sequential","order","handler","baseLng","__lngVersion__","Date","now","console","log","buildEnd","filePath","file","distPath","dist","fs","readFile","err","data","newest","changed","baseData","a","b","stats","deleted","added","keyA","keyB","decade","JSON","writeFile","stringify","error","copyFile","updateFileLanguage"],"mappings":"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"}